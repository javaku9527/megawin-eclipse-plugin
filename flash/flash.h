#define false	0
#define true	1

#define ERROR_OK						(0)
#define ERROR_NO_CONFIG_FILE			(-2)
#define ERROR_BUF_TOO_SMALL				(-3)
#define ERROR_FAIL						(-4)
#define ERROR_WAIT						(-5)
#define ERROR_TIMEOUT_REACHED			(-6)
#define ERROR_NOT_IMPLEMENTED			(-7)

// SET
#define SET_MLINK_SWD_LINE_RST  0x0101
#define SET_MLINK_JTAG_TO_SWD   0x0201
#define SET_ICE_END	            0x0401
#define SET_ICP_INIT            0x0a01
#define SET_OPEN_PULLUP_R       0x0d01
#define SET_ICE_DAP             0x0f01

// ERASE
#define ERASE_CHIP            	0x0202

// READ
#define READ_ICE_DAP            0x0104
#define READ_DUT_ID	            0x0904
#define READ_CFG		       	0x0a04

// PROGRAM
#define PROGRAM_CODE            0x0105
#define PROGRAM_OR              0x0205

// MLINK CONFIG
#define VID = 0x0E6A
#define PID = 0x0325
#define VCP_PID = 0x0331
#define MLINK_INTERFACE      		 0
#define MLINK_VCP_INTERFACE   		 2
#define HID_PACKET_SIZE   		  0x80

// 
#define MLINK_CMD_SIZE     		   128
#define MLINK_DATA_SIZE     	  1024

static inline void buf_set_u32(uint8_t *_buffer,
	unsigned first, unsigned num, uint32_t value)
{
	uint8_t *buffer = _buffer;

	if ((num == 32) && (first == 0)) {
		buffer[3] = (value >> 24) & 0xff;
		buffer[2] = (value >> 16) & 0xff;
		buffer[1] = (value >> 8) & 0xff;
		buffer[0] = (value >> 0) & 0xff;
	} else {
		for (unsigned i = first; i < first + num; i++) {
			if (((value >> (i - first)) & 1) == 1)
				buffer[i / 8] |= 1 << (i % 8);
			else
				buffer[i / 8] &= ~(1 << (i % 8));
		}
	}
}

static inline uint32_t le_to_h_u32(const uint8_t *buf)
{
	return (uint32_t)((uint32_t)buf[0] | (uint32_t)buf[1] << 8 | (uint32_t)buf[2] << 16 | (uint32_t)buf[3] << 24);
}

#define DEVICE_ARRAY_SIZE 10

struct device
{
	uint8_t pOR[32];			
    uint32_t dwDeviceID;
};

struct device device_array[DEVICE_ARRAY_SIZE] = {
	{ {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xEF,0xED,0xFF,0xFF,0xFF,0xFF,0xC8,0xFF,0xFF,0xFF}, 0xFF04C001 }, // MA862
	{ {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xEF,0xED,0xFF,0xFF,0xFF,0xFF,0xC8,0xFF,0xFF,0xFF}, 0xFF05C000 }, // MG32F02A132
	{ {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xEF,0xED,0xFF,0xFF,0xFF,0xFF,0xC8,0xFF,0xFF,0xFF}, 0xFF05C008 }, // MG32F02A072
	{ {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xEF,0xED,0xFF,0xFF,0xFF,0xFF,0xC8,0xFF,0xFF,0xFF}, 0xFF05C010 }, // MG32F02A032 
	{ {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xCF,0xED,0xFF,0xFF,0xFF,0xFF,0xC8,0xFF,0xFF,0xFF}, 0xFF05C017 }, // MG32F02V032
    { {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xCF,0xED,0xFF,0xFF,0xFF,0xFF,0xC8,0xFF,0xFF,0xFF}, 0xFF05C020 }, // MG32F02U128
	{ {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xCF,0xED,0xFF,0xFF,0xFF,0xFF,0xC8,0xFF,0xFF,0xFF}, 0xFF05C021 }, // MG32F02A128
	{ {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xCF,0xED,0xFF,0xFF,0xFF,0xFF,0xC8,0xFF,0xFF,0xFF}, 0xFF05C028 }, // MG32F02U064
	{ {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xCF,0xED,0xFF,0xFF,0xFF,0xFF,0xC8,0xFF,0xFF,0xFF}, 0xFF05C029 }, // MG32F02A064
	{ {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xCF,0xED,0xFF,0xFF,0xFF,0xFF,0xC8,0xFF,0xFF,0xFF}, 0xFF05C02C }  // MG32F02U031
};