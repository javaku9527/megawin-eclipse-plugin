#define false									0
#define true									1

#define ERROR_OK							  (0)
#define ERROR_NO_CONFIG_FILE				 (-2)
#define ERROR_BUF_TOO_SMALL					 (-3)
#define ERROR_FAIL							 (-4)
#define ERROR_WAIT						 	 (-5)
#define ERROR_TIMEOUT_REACHED				 (-6)
#define ERROR_NOT_IMPLEMENTED				 (-7)

// SET
#define SET_MLINK_SWD_LINE_RST  	  	   0x0101
#define SET_MLINK_JTAG_TO_SWD   	 	   0x0201
#define SET_ICE_END	    			  	   0x0401
#define SET_ICP_INIT            	  	   0x0a01
#define SET_OPEN_PULLUP_R       	  	   0x0d01
#define SET_ICE_DAP             	  	   0x0f01

// ERASE
#define ERASE_CHIP            		  	   0x0202

// READ
#define READ_ICE_DAP            	  	   0x0104
#define READ_DUT_ID	            	  	   0x0904
#define READ_CFG		       		  	   0x0a04

// PROGRAM
#define PROGRAM_CODE            	  	   0x0105
#define PROGRAM_OR              	  	   0x0205

// MLINK CONFIG
#define VID 						  	   0x0E6A
#define PID 						  	   0x0325
#define VCP_PID 					  	   0x0331
#define MLINK_CONTROL_INTERFACE			   		0
#define MLINK_INTERRUPT_INTERFACE		   		0
#define MLINK_VCP_LINUX_CONTROL_INTERFACE		0
#define MLINK_VCP_WINDOWS_CONTROL_INTERFACE		2
#define MLINK_VCP_INTERRUPT_INTERFACE      		2
#define HID_PACKET_SIZE   		  			 0x80

// 
#define MLINK_CMD_SIZE     		   		 	  128
#define MLINK_DATA_SIZE     	  			 1024

static inline void buf_set_u32(uint8_t *_buffer,
	unsigned first, unsigned num, uint32_t value)
{
	uint8_t *buffer = _buffer;

	if ((num == 32) && (first == 0)) {
		buffer[3] = (value >> 24) & 0xff;
		buffer[2] = (value >> 16) & 0xff;
		buffer[1] = (value >> 8) & 0xff;
		buffer[0] = (value >> 0) & 0xff;
	} else {
		for (unsigned i = first; i < first + num; i++) {
			if (((value >> (i - first)) & 1) == 1)
				buffer[i / 8] |= 1 << (i % 8);
			else
				buffer[i / 8] &= ~(1 << (i % 8));
		}
	}
}

static inline uint32_t le_to_h_u32(const uint8_t *buf)
{
	return (uint32_t)((uint32_t)buf[0] | (uint32_t)buf[1] << 8 | (uint32_t)buf[2] << 16 | (uint32_t)buf[3] << 24);
}

#define DEVICE_ARRAY_SIZE 10

struct device
{
	char name[32];
	uint8_t pOR[32];			
    uint32_t deviceId;
	uint32_t partNum;
};

struct device device_array[DEVICE_ARRAY_SIZE] = {
	{ "MG32F02A132", {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xEF,0xED,0xFF,0xFF,0xFF,0xFF,0xC8,0xFF,0xFF,0xFF}, 0xFF05C000, 0x00}, // MG32F02A132
	{ "MG32F02A072", {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xEF,0xED,0xFF,0xFF,0xFF,0xFF,0xC8,0xFF,0xFF,0xFF}, 0xFF05C008, 0x02}, // MG32F02A072
	{ "MG32F02A032", {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xEF,0xED,0xFF,0xFF,0xFF,0xFF,0xC8,0xFF,0xFF,0xFF}, 0xFF05C010, 0x04}, // MG32F02A032 
	{ "MA862"	   , {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xEF,0xED,0xFF,0xFF,0xFF,0xFF,0xC8,0xFF,0xFF,0xFF}, 0xFF04C001, 0x06}, // MA862
    { "MG32F02U128", {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xCF,0xED,0xFF,0xFF,0xFF,0xFF,0xC8,0xFF,0xFF,0xFF}, 0xFF05C020, 0x16}, // MG32F02U128
	{ "MG32F02U064", {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xCF,0xED,0xFF,0xFF,0xFF,0xFF,0xC8,0xFF,0xFF,0xFF}, 0xFF05C021, 0x18}, // MG32F02A128
	{ "MG32F02U064", {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xCF,0xED,0xFF,0xFF,0xFF,0xFF,0xC8,0xFF,0xFF,0xFF}, 0xFF05C028, 0x1A}, // MG32F02U064
	{ "MG32F02A064", {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xCF,0xED,0xFF,0xFF,0xFF,0xFF,0xC8,0xFF,0xFF,0xFF}, 0xFF05C029, 0x1C}, // MG32F02A064
	{ "MG32F02V032", {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xCF,0xED,0xFF,0xFF,0xFF,0xFF,0xC8,0xFF,0xFF,0xFF}, 0xFF05C017, 0x1E}, // MG32F02V032
	{ "MG32F02U031", {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xCF,0xED,0xFF,0xFF,0xFF,0xFF,0xC8,0xFF,0xFF,0xFF}, 0xFF05C02C, 0x22}  // MG32F02U031
};